1a) "Wann ist es sinnvoll, Methoden als Klassenmethoden zu definieren? Welche
Einschränkungen entstehen dabei?"

Es macht Sinn, Klassenmethoden (Statische Methoden) zu nutzen, wenn eine der
folgendeen Bedingungen zutrifft:
- Die Methode verändert nichts an einer Instanz der Klasse und greift nicht auf die
  Attribute einer Instanz zu. Dies ist zum Beispiel bei Klassen so, die exklusiv
  unterschiedliche Sortier-Methoden bereitstellen.
- Die Methode soll verfügbar sein, ohne eine Instanz der Klasse zu erstellen.
- Die Methode soll im "statischen Kontext verfügbar sein.
  Gemeint sind ``static{...}`` Blöcke und andere statische Methoden.
- Die Methode greift auf ein oder mehr Instanzen zu, die möglicherweise null sein
  können. Wenn eine solche Methode oft an unterschiedlichen Stellen aufgerufen wird,
  kann das viele redundante null-Checks sparen.
- Java hat ein Feature, das man ``static import`` nennt. Dadurch können Methoden aus
  anderen Dateien aufgerufen werden, ohne die Urkunft der Methode anzugeben.
  ZB könnte man ``Math`` statisch importieren und dann statt ``Math.abs(num)`` einfach
  ``abs(num)`` schreiben.
  Ob das gut oder schlecht ist, muss der Entwickler/die Entwicklerin für sich
  entscheiden.
- Das Erstellen einer neuen Instanz via ``new`` ist sehr langsam. Mit statischen
  Methoden ist das, falls nur statische Variablen und -Methoden benötigt werden,
  nicht notwendig.
- Java unterstützt ``nested classes`` (Unterklassen, wie sie in der ``Stein`` Klasse
  aus Übung 7 genutzt werden können). Diese werden in den meisten Fällen als statisch
  deklariert, um viel Overhead zu vermeiden. Statische, nested Klassen können nur auf
  statische Methoden und Variablen der Überklasse zugreifen. Hier macht es also Sinn,
  statische Methoden zu nutzen.

Klassenmethoden haben wenige, aber starke Einschränkungen:
- Klassenmethoden können nicht auf die nicht-statischen Attribute der Klasse zugreifen,
  wenn keine Instanz im statischen Kontext verfügbar ist, in der Methode erstellt wird
  oder als Parameter übergeben wird.
- Wegen der Reihenfolge, in der Klassen geladen werden, kann es vorkommen, dass eine
  Methode nicht auf statische Variablen oder Methoden einer anderen Klasse zugreifen kann.
  Dadurch kann es zu Fehlern kommen, bevor das Programm überhaupt gestartet hat!
- Der Aufruf statischer Methoden kann (auch wenn man den Overhead des ``new``
  Schlüsselwortes ignoriert) schneller sein als der Aufruf einer Instanz-Methode.

Fun Fact:
Viele der Schwächen von static lassen sich vermeiden, indem man beispielsweise das
"Singleton"-Pattern verwendet. Dann wird nur eine Instanz der Klasse erstellt.
Dadurch ist nur eine Instanz der Klasse notwendig (daher wird nur einmal ``new``
genutzt).

1b) "Warum macht es keinen Sinn, lokale Variablen als private zu deklarieren? Können
Klassenmethoden als private deklariert werden? Wenn ja: wann wäre das sinnvoll?"

Die Frage ist "Warum macht es keinen Sinn, lokale Variablen als private zu
deklarieren?".
Wir vermuten, dass mit "lokal" hier der Bereich innerhalb einer Methode gemeint ist.
In Java ist es aber gar nicht möglist jch, dort eine Variable als private zu deklarieren.

Variablen innerhalb einer Methode sind so oder so nicht von außen verfügbar,
während die Methode noch läuft. (Die Variable kann natürlich in einer anderen
Klasse gespeichert oder via ``return`` zurückgegeben werden, aber das ist hier
nicht wichtig.)

Klassenmethoden können als private deklariert werden. Das ist sinnvoll, wenn nur
Instanzen der Klasse oder die Klasse selbst auf die Methode zugreifen soll.

1c) "Was passiert, wenn in einer Klassendefinition kein Konstruktor definiert wird?
Können Konstruktoren vererbt werden? Können Konstruktoren als private deklariert
werden?"

Wenn kein Konstruktor explizit deklariert wird, erhält die Klasse einen standard-
Konstruktor, der keine Argumente erhält und nichts tut. Die Variablen der Klasse
erhalten ihre normalen Initialwerte. Wenn sie nicht explizit mit Wert definiert wurden,
werden Referenz-Typen als Null, Booleans als false und Zahlentypen als 0 initialisiert.

In der objektorientierten Programmierung werden folgende Eigenschaften vererbt:
- fields (Variablen)
- Methoden
- Nested classes (Unterklassen)
Konstruktoren gehören zu keiner dieser Gruppen. Die können aber von Subklassen
aufgerufen werden.
Quelle: https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

Konstruktoren können als private deklariert werden. In diesem Fall ist der
Konstruktor nur in der Klasse selbst und in nested Klassen sichtbar. Private
Konstruktoren werden beim oben genannten Singleton-Pattern und bei Klassen
verwendet, die nur statische Methoden enthalten, wie die Klasse ``java.lang.Math``.

1d) "Wo sind Instanzvariablen sichtbar, wenn diese als protected deklariert werden?
Können Konstruktoren als protected deklariert werden?"

Variablen, Methoden und Konstruktoren, die als protected deklariert werden, sind in
Kind-Klassen und für andere Klassen im selbeen Package sichtbar.
Im Falle der Kindklassen ist es egal, in welcher Package sich diese befinden.

Hier ist eine Tabelle der Sichtbarkeiten:
https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

Modifier  | Class | Package | Subclass | Global
-----------------------------------------------
public    | Y     | Y       | Y        | Y
protected | Y     | Y       | Y        | N
<non>     | Y     | Y       | N        | N
private   | Y     | N       | N        | N

(Ich habe diese getestet und bin ein wenig schockiert, dass protected Members
allen Klassen im selben Package zur Verfügung stehen.)

1e) "Was sind abstrakte Klassen? Wozu sind sie gut? Können Variablen einer abstrakten
Klasse deklariert werden?"

Abstrakte Klassen sind Klassen, die mit dem ``abstract`` markiert wurden. Sie können Methoden, Konstruktoren, Felder und
genestete Klassen enthalten. Methoden könnenn als abstrakt markiert werden.
Abstrakte Methoden enthalten keine Instruktionen, nur ihre Signatur. Diese Methoden müssen von allen Kind-Klassen der
Klasse überschrieben werden.

Durch abstrakte Klassen kann man, wie mit Interfaces, eine Abstraktion für anderen Code darstellen (Polymorphie). Der
Vorteil gegenüber Interfaces ist, das abstrakte Klassen auch Methoden mit Körper oder Felder enthalten können.

Es ist möglich, Variablen mit einem abstrakten Typ deklariert werden. Diesen können das Objekte aller erbenden Klassen
zugewiesen werden.

1f) "Können Objekte einer abstrakten Klasse erzeugt werden? Kann man Konstruktoren in abstrakten Klassen definieren?"

public abstract class Liquid { public Liquid(int i) {...} public abstract String name(); }

Das Erstellen einer neuen Instanz dieser Klasse ohne eine neue Klasse, die die abstrakte Klasse erweitert, ist unmöglich.
Etwas ähnliches kann aber auf zwei Wegen gemacht werden:
- In einer neuen Datei (Der normale, langweilige Weg)
- Mit inline Syntax.

Das Inlining einer neuen Implementation der Klasse von oben sieht wie folgt aus:
  new Liquid (n) {
    @Override
    public String name() { ... }
  }

Dadurch wird trotzdem eine neue Klasse erstellt. Diese muss, wie üblich, alle abstrakten Methoden der Superklasse
überschreiben. Diese annonyme Klasse darf keinen eigenen Konstruktor implementieren.

Eine abstrakte Klasse kann eigene Konstruktoren implementieren. Diese müssen mit dem Befehl
    super(...)
aufgerufen werden.

1g) "Kann eine Variable vom Typ A einem Objekt der Klasse B zugewiesen werden, wenn A eine Unterklasse von B ist?
Begründen Sie Ihre Antwort."

Ich schätze, dass folgendes Gemeint ist:
A v = new B();
Diese Zuweisung ist nicht "legal",
Jedes Objekt der Klasse A ist ein Objekt der Klasse B aber Objekte der Klasse B sind nicht unbedingt Objekte der Klasse A.
In technischen Worten: Klasse A könnte beispielsweise andere/mehr Methoden und Variablen als B haben. Damit hätten die
beiden Typen eine unterschiedliche Größe und wären inkompatibel.

1h) "Können Variablen einer Klassen in Unterklassen überschrieben werden?"

Variablen einer Klasse können nicht überschrieben sondern nur "geschattet" werden. Das heißt, dass es eine neue Variable
mit demselben Namen gibt. Die alte Variable existiert aber immer noch.

1i) "Was ist automatisches boxing/unboxing? Warum wurde das in Java eingeführt? Welche Probleme gibt es in Java damit?"

Java hat "primitive" Datentypen wie int, char oder double. Diese erben nicht von Object und werden direkt "by value"
statt "by object-reference" referenziert.
Unter bestimmten Umständen kann eine Variable eines primitiven Datentyps automatisch in ein Objekt umgewandelt werden.
    int -> Integer
    short -> Short
    boolean -> Boolean
    usw.
Solche Objekte erben von Object.

Dise Umwandlung wurde eingeführt, damit auch Methoden wie
    String foo(Object)
mit einem int als Parameter instanziiert werden kann. (``foo(1)``)
In diesem Fall findet ein automatischen Boxing statt.
Im umgekehrten Fall kann auch ein automatisches Unboxing stattfinden:
    int zero = Integer.valueOf(0);

Außerdem funktionieren generische Klassen in Java nicht mit primitiven Datentypen. Also kann es keine ArrayList<int>
geben. Stattdessen muss eine ArrayList<Integer> erstellt werden.
Vielleicht ändert sich das in der Zukunft. Siehe Projekt "Valhalla".
    https://openjdk.java.net/projects/valhalla/

Probleme damit gibt es für:
- Performanceprobleme durch unerwartetes Boxing
  In Java ist es relativ leicht einzuschätzen, wann Boxing/Unboxing auftritt. In Sprachen wie Kotlin, die versuchen,
  dieses Verhalten zu verbergen, kann es aber zu massiven Problemen führen.
- Vergleiche mit '==' und '!='
  Die Primitiven Typen werden per Wert verglichen.
    (0xFFFFFFFF == 0xFFFFFFFF) ist immer true.
  Objekte werden bei '==' und '!=' durch ihre Referenz verglichen.
    (Integer.valueOf(0xFFFFFFFF) == Integer.valueOf(0xFFFFFFFF)) ist false!

1j) "Was ist eine generische Klasse? Wozu sind diese gut?"

In a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods.
Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use
the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to
type parameters are types.

- Elimieren von überflüssigen Tasks gegenüber rohen Typen.
  Bei rohen Collections müssen alle Objekte gecastet werden:
    List os = ...;
    String s = (String) os.get(1);
  Mit generischen Typen ist das nicht notwendig.
    List<String> os = ...;
    String s = os.get(1);
- Besseres Checken des Typs zur Compile-Zeit.
  Der Java-Compiler kann das oben genannte Szenario des überflüssigen Casts nicht leicht eliminieren.
- Weniger Code.
  Um das Problem von vielen Casts mit rohen Collections zu umgehen, haben manche Bibliotheken einfach dutzende
  verschiedene Typen erstellt, die das gleiche für unterschiedliche Typen tun.
  Beispiel:
    StringList
    FileList
    NumberList
    ...
  Durch Generics kann das stark abgekürzt werden:
    List<...>

1k) "Was verstehen Sie unter Vererbungspolymorphie?"

Vererbungspolymorphie bedeutet, dass unterschiedliche Klassen, die eine gemeinsame Oberklasse oder ein gemeinsames
Interface haben, gleich aufgerufen werden können. Bei diesen Aufrufen können sie sich aber unterschiedlich verhalten
(unterschiedliche Werte erzeugen oder andere Berechnungen durchführen).

Ein übliches Beispiel ist das Form-Kreis-Rechteck-Beispiel.
Alle Formen haben einen Umfang. Der Umfang wird aber für Kreise und Rechtecke unterschiedlich berechnet.

1l) "Was sind Ausnahmefehler? Was ist der Unterschied zwischen Runtime-Exceptions und allgemeinen Exceptions in Java?"

Ausnahmefehler (Im folgenden "Exception" genannt) sind Events, die während des Ablaufs eines Programmes in unerwünschten
Fällen auftreten. Sie unterbrechen den Ablauf des aktuellen Scopes und springen zum nächsten ``try{...}catch(...) {...}``
Block, der ihren Typ behandelt.
Wenn der Fehler nicht behandelt wird, also aus ``main`` ausbricht, wird der Fehler ausgegeben und das Programm terminiert.
Im Gegensatz zu Errors beschreiben Exceptions zwar einen Fehlerfall, aber nicht unbedingt einen kritischen Fehler.

Normale Exceptions erben von von Exception und müssen durch einen try-catch Block aufgefangen werden oder die Methode
muss in ihrer Signatur den spezifischen Typ angeben:
  public void foo(int ml) throws Exception

Runtime-Exceptions erben von RuntimeException und müssen nicht durch einen try-catch Block aufgefangen werden und nicht
in der Signatur der Methode angegeben werden.
Dazu gehören Fehler wie die Teilung durch 0 oder das Aufrufen einer Methode auf null.
