1a) Was sind Iteratoren? Wozu sind sie gut?
Iteratoren bieten ein einheitliches Interface, um Collections abzulaufen. Jeder Typ von Collection hat eine eigene Implementation für Iteratoren.
Jeder von ihnen muss folgende FUnktionalitäten bereitstellen:
boolean hasNext()
- Kontrolliert, ob mehr Elemente in der Collection sind.
T next()
- Generische Methode, die das nächste Element der Collection zurückgibt und den aktuellen "Pointer" auf das nächste Element zeigen lässt. Wenn kein weiteres Element vorhanden ist, wird eine NoSuchElementException geworfen.
void remove()
- Löscht das aktuelle Element. Diese Methode kann von jedem Iterator aufgerufen werden, aber viele werfen nur eine UnsupportedOperationException.

1b) Was sind abstrakte Datentypen?
Abstrakte Klassen können
- Attribute, Methoden Konstruktoren und innere Klassen enthalten
- Eine andere Klasse erweitern
- Interfaces implementieren
- Abstrakte Methoden enthalten
Abtrakte Klassen können nicht
- Als "final" markiert werdeen
Es ist nicht möglich, eine Instanz einer absstrakten Klassee direkt zu initialisieren. Dafür muss eine neue Klasse erstellt werden, die die abstrakte Klasse erweitert.
Wenn die abstrakte Klasse ein Interface implementiert oder von einer abstrakten Klasse erbt, die abstrakte Methoden enthält, müssen die abstrakten Methoden nicht implementiert werden.

1c) Was verstehen Sie unter dynamische Datenstrukturen?
Dynamischee Datenstrukturen sind Sammlungstypen (Sets, Maps, Listen, Bags, Heaps, Cons-Cells, ...), die ihre Größe ihrem Inhalt anpassen können.
Beispielsweise wird eine Liste, die mithilfe eines statischen Arrays implementiert wurde, mit einer Kapazität (Größe des Arrays) von 16 Elementen initialisiert. Wenn das 17. Element eingefügt werden soll, wird zuerst die Kapazität verdoppelt.

1d) Was ist eine allgemein akzeptierte Klassifizierung von ADT-Operationen?
Ich schätze, hiermit sind Creators, Producers, Observers und Mutators gemeint.
- Creators erstellen neue Objecte einer Klasse. Sie können einen Input eines anderen Typs erhalten. (List::of(T...))
- Producers erstellen neue Objekte einer Klasse mit Methoden, die mindestenss ein Objekt des Output-Typs erhalten. (Integer::sum(Integer, Integer))
- Observers können die Attribute eines abstrakten Typs abrufen und als Objekte eines anderen Typs zurückgeben. (List::size)
- Mutators bearbeiten Objekte. (List::add)

1e) Was ist eine innere Klassendefinition wann ist es von Vorteil innere Klassen zu definieren?
Innere Klassen sind Klassen, die innerhalb einer Top-Level-Klasse oder eines Blockes definiert werden. Sie können auf private Felder und Methoden der Top-Level-Klasse zugreifen und (wenn die Oberklasse generisch ist) auf den Compile-Zeit-Typ zugreifen (siehe Bsp 1). Sie können selbst Felder, Methoden und Konstruktoren haben. Sie können als static deklariert werden. Das sorgt für weniger Overhead, aber der Zugriff auf generische Typen ist nicht mehr möglich (siehe Bsp 2).

Wann verwenden?
- Für Iteratoren (Zugriff auf Implementation der Top-Level-Klasse ist sehr nützlich)
- Bei Benutzeroberflächen
- Bei lokalen, 1st-Level FUnktionen (Zugriff auf lokale Variablen ist möglich)

Bsp:
class Coll<T> {
    private class Itr {
        T t;
        ...
    }
    ...
}

Bsp 2:
class Coll<T> {
    private static class Itr {
        T t; // FEHLER: T ist hier nicht sichtbar!
        ...

    ...}
}

1f) Was ist der Unterschied zwischen einer Elementklasse und einer lokalen Klasse in Java?
Eine Elementklasse wird innerhalb einer anderen Klasse definiert.
Eine lokale Klasse wird innerhalb einer Methode oder eines Blocks definiert.

Elementklasse:
public class A {
    class B {}
}

Lokale Klasse:
void foo() {
    class C {}
    var c = new C();
}

1g) Warum werden Dummy-Knoten bei der Implementierung von verketteten Listen verwendet?
Dummy-Knoten eignen sich dafür, die Anzahl der if-else Blöcke in Einfüge- und Lösch-Operationen in verlinkten Datenstrukturen zu reduzieren.

``if head==null`` und ``if tail==null`` können dadurch vermieden werden, head und tail einer Linked List als Dummy-Knoten bereitzustellen.

